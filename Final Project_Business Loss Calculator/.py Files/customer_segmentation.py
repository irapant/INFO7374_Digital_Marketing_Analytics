# -*- coding: utf-8 -*-
"""Customer Segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16WJNg3Uo8yZfUNksp-cssfLTmcRqbSxg
"""

import pandas as pd
import numpy as np

import time, warnings
import datetime as dt

#modules for predictive models
import sklearn.cluster as cluster
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
#from sklearn.mixture import GMM

from sklearn.metrics import silhouette_samples, silhouette_score

#visualizations
import matplotlib.pyplot as plt
from pandas.plotting import scatter_matrix
# %matplotlib inline
import seaborn as sns

warnings.filterwarnings("ignore")

#load the dataset
retail_df = pd.read_excel("Online_Marketing_Sales_Finaldataset.xlsx")

retail_df.head()

#check the shape
retail_df.shape

#remove canceled orders
retail_df = retail_df[retail_df['Quantity']>0]
retail_df.shape

#remove rows where customerID are NA
retail_df.dropna(subset=['CustomerID'],how='all',inplace=True)
retail_df.shape

#restrict the data to one full year because it's better to use a metric per Months or Years in RFM
retail_df = retail_df[retail_df['InvoiceDate']>= "2010-12-09"]
retail_df.shape

print("Summary..")
#exploring the unique values of each attribute
print("Number of transactions: ", retail_df['InvoiceNo'].nunique())
print("Number of products bought: ",retail_df['StockCode'].nunique())
print("Number of customers:", retail_df['CustomerID'].nunique() )
print("Percentage of customers NA: ", round(retail_df['CustomerID'].isnull().sum() * 100 / len(retail_df),2),"%" )

"""RFM Analysis
RFM (Recency, Frequency, Monetary) analysis is a customer segmentation technique that uses past purchase behavior to divide customers into groups. 
RFM helps divide customers into various categories or clusters to identify customers who are more likely to respond to promotions and also for future personalization services.

RECENCY (R): Days since last purchase
FREQUENCY (F): Total number of purchases
MONETARY VALUE (M): Total money this customer spent.
We will create those 3 customer attributes for each customer.

**Recency:**

To calculate recency, we need to choose a date point from which we evaluate how many days ago was the customer's last purchase.
"""

#last date available in our dataset
retail_df['InvoiceDate'].max()

"""The last date we have is "2018-12-09" so we will use it as reference."""

now = dt.date(2018,12,9)
print(now)

#create a new column called date which contains the date of invoice only
retail_df['date'] = retail_df['InvoiceDate'].dt.date

retail_df.head()

#group by customers and check last date of purshace
recency_df = retail_df.groupby(by='CustomerID', as_index=False)['date'].max()
recency_df.columns = ['CustomerID','LastPurshaceDate']
recency_df.head()

#calculate recency
recency_df['Recency'] = recency_df['LastPurshaceDate'].apply(lambda x: (now - x).days)

recency_df.head()

#drop LastPurchaseDate as we don't need it anymore
recency_df.drop('LastPurshaceDate',axis=1,inplace=True)

"""Now we have the recency attribute created. e.g: Customer with ID = 12346 did his/her last purshace 325 days ago.

**Frequency**

Frequency helps us to know how many times a customer purchased from us. To do that we need to check how many invoices are registered by the same customer.
"""

# drop duplicates
retail_df_copy = retail_df
retail_df_copy.drop_duplicates(subset=['InvoiceNo', 'CustomerID'], keep="first", inplace=True)
#calculate frequency of purchases
frequency_df = retail_df_copy.groupby(by=['CustomerID'], as_index=False)['InvoiceNo'].count()
frequency_df.columns = ['CustomerID','Frequency']
frequency_df.head()

"""Monetary

Monetary attribute answers the question: How much money did the customer spent over time?

To do that, first, we will create a new column total cost to have the total price per invoice.
"""

#create column total cost
retail_df['TotalCost'] = retail_df['Quantity'] * retail_df['UnitPrice']

monetary_df = retail_df.groupby(by='CustomerID',as_index=False).agg({'TotalCost': 'sum'})
monetary_df.columns = ['CustomerID','Monetary']
monetary_df.head()

"""**Create RFM Table**"""

#merge recency dataframe with frequency dataframe
temp_df = recency_df.merge(frequency_df,on='CustomerID')
temp_df.head()

#merge with monetary dataframe to get a table with the 3 columns
rfm_df = temp_df.merge(monetary_df,on='CustomerID')
#use CustomerID as index
rfm_df.set_index('CustomerID',inplace=True)
#check the head
rfm_df.head()

"""Customer with ID = 12346 has recency: 325 days, frequency:1, and monetary: 77183.60$

RFM Table Correctness verification
"""

retail_df[retail_df['CustomerID']==12346.0]

(now - dt.date(2018,1,18)).days == 325

"""Customer segments with RFM Model

Before moving to customer segments, Let's see the application of Pareto Principle â€“ commonly referred to as the 80-20 rule on our dataset by applying it to our RFM variables.

Similarly, 20% customers contribute to 80% of your total revenue. Let's verify that because that will help us know which customers to focus on when marketing new products.

**Applying 80-20 rule**
"""

#get the 80% of the revenue
pareto_cutoff = rfm_df['Monetary'].sum() * 0.8
print("The 80% of total revenue is: ",round(pareto_cutoff,2))

customers_rank = rfm_df
# Create a new column that is the rank of the value of coverage in ascending order
customers_rank['Rank'] = customers_rank['Monetary'].rank(ascending=0)
#customers_rank.drop('RevenueRank',axis=1,inplace=True)
customers_rank.head()

"""**Top Customers**"""

customers_rank.sort_values('Rank',ascending=True)

#get top 20% of the customers
top_20_cutoff = 4339 *20 /100
top_20_cutoff

#sum the monetary values over the customer with rank <=773
revenueByTop20 = customers_rank[customers_rank['Rank'] <= 772]['Monetary'].sum()
revenueByTop20

"""Applying RFM score formula

The simplest way to create customers segments from RFM Model is to use Quartiles. We assign a score from 1 to 4 to Recency, Frequency and Monetary. Four is the best/highest value, and one is the lowest/worst value. A final RFM score is calculated simply by combining individual RFM score numbers.

Note: Quintiles (score from 1-5) offer better granularity, in case the business needs that but it will be more challenging to create segments since we will have 555 possible combinations. So, we will use quartiles.

**RFM Quartiles**
"""

quantiles = rfm_df.quantile(q=[0.25,0.5,0.75])
quantiles

quantiles.to_dict()

"""**Creation of RFM segmentation table**

We will create two segmentation classes since, high recency is bad, while high frequency and monetary value is good
"""

# Arguments (x = value, p = recency, monetary_value, frequency, d = quartiles dict)
def RScore(x,p,d):
    if x <= d[p][0.25]:
        return 4
    elif x <= d[p][0.50]:
        return 3
    elif x <= d[p][0.75]: 
        return 2
    else:
        return 1
# Arguments (x = value, p = recency, monetary_value, frequency, k = quartiles dict)
def FMScore(x,p,d):
    if x <= d[p][0.25]:
        return 1
    elif x <= d[p][0.50]:
        return 2
    elif x <= d[p][0.75]: 
        return 3
    else:
        return 4

#create rfm segmentation table
rfm_segmentation = rfm_df
rfm_segmentation['R_Quartile'] = rfm_segmentation['Recency'].apply(RScore, args=('Recency',quantiles,))
rfm_segmentation['F_Quartile'] = rfm_segmentation['Frequency'].apply(FMScore, args=('Frequency',quantiles,))
rfm_segmentation['M_Quartile'] = rfm_segmentation['Monetary'].apply(FMScore, args=('Monetary',quantiles,))

rfm_segmentation.head()

"""Now that we have the score of each customer, we can represent our customer segmentation.

First, we need to combine the scores (R_Quartile, F_Quartile,M_Quartile) together.
"""

rfm_segmentation['RFMScore'] = rfm_segmentation.R_Quartile.map(str) \
                            + rfm_segmentation.F_Quartile.map(str) \
                            + rfm_segmentation.M_Quartile.map(str)
rfm_segmentation.head()

"""Best Recency score = 4: most recently purchase. Best Frequency score = 4: most quantity purchase. Best Monetary score = 4: spent the most.

Let's see who are our Champions (best customers).
"""

rfm_segmentation[rfm_segmentation['RFMScore']=='444'].sort_values('Monetary', ascending=False).head(10)

print("Best Customers: ",len(rfm_segmentation[rfm_segmentation['RFMScore']=='444']))
print('Loyal Customers: ',len(rfm_segmentation[rfm_segmentation['F_Quartile']==4]))
print("Big Spenders: ",len(rfm_segmentation[rfm_segmentation['M_Quartile']==4]))
print('Almost Lost: ', len(rfm_segmentation[rfm_segmentation['RFMScore']=='244']))
print('Lost Customers: ',len(rfm_segmentation[rfm_segmentation['RFMScore']=='144']))
print('Lost Cheap Customers: ',len(rfm_segmentation[rfm_segmentation['RFMScore']=='111']))

a= len(rfm_segmentation[rfm_segmentation['RFMScore']=='444'])
b=len(rfm_segmentation[rfm_segmentation['F_Quartile']==4])
c=len(rfm_segmentation[rfm_segmentation['M_Quartile']==4])
d=len(rfm_segmentation[rfm_segmentation['RFMScore']=='244'])
e=len(rfm_segmentation[rfm_segmentation['RFMScore']=='144'])
f=len(rfm_segmentation[rfm_segmentation['RFMScore']=='111'])

RFM = ('Best Customer', 'Loyal Customers','Big Spenders','Almost Lost', 'Lost Customers', 'Lost Cheap Customers')
y_pos = np.arange(len(RFM))
performance = [a,b,c,d,e,f]

plt.bar(y_pos, performance, align='center', alpha=0.5)
plt.xticks(y_pos, RFM)
plt.ylabel('Count')
plt.title('Customers based on RFM values')

plt.show()

"""For example:

Best Customers - Champions: Reward them. They can be early adopters to new products. Suggest them "Refer a friend".

At Risk: Send them personalized emails to encourage them to shop.
"""

best_df= rfm_segmentation[rfm_segmentation['RFMScore']=='444'].sort_values('Monetary', ascending=False)

best_df.head()

lost_df= rfm_segmentation[rfm_segmentation['RFMScore']=='144'].sort_values('Monetary', ascending=False)

lost_df

lostcheapcust_df= rfm_segmentation[rfm_segmentation['RFMScore']=='111'].sort_values('Monetary', ascending=False)

lostcheapcust_df.head()

